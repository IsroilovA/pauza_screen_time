import Flutter
import FamilyControls
import Foundation

final class RestrictionsMethodHandler {
    private static let iosFamilyControlsKey = "ios.familyControls"
    private static let featureRestrictions = "restrictions"
    private static let platformIOS = "ios"

    func handle(_ call: FlutterMethodCall, result: @escaping FlutterResult) {
        switch call.method {
        case MethodNames.configureShield:
            handleConfigureShield(call: call, result: result)
        case MethodNames.setRestrictedApps:
            handleSetRestrictedApps(call: call, result: result)
        case MethodNames.addRestrictedApp:
            handleAddRestrictedApp(call: call, result: result)
        case MethodNames.removeRestriction:
            handleRemoveRestriction(call: call, result: result)
        case MethodNames.isRestricted:
            handleIsRestricted(call: call, result: result)
        case MethodNames.removeAllRestrictions:
            handleRemoveAllRestrictions(call: call, result: result)
        case MethodNames.getRestrictedApps:
            handleGetRestrictedApps(call: call, result: result)
        case MethodNames.isRestrictionSessionActiveNow:
            handleIsRestrictionSessionActiveNow(result: result)
        case MethodNames.isRestrictionSessionConfigured:
            handleIsRestrictionSessionConfigured(result: result)
        case MethodNames.pauseEnforcement:
            handlePauseEnforcement(call: call, result: result)
        case MethodNames.resumeEnforcement:
            handleResumeEnforcement(result: result)
        case MethodNames.getRestrictionSession:
            handleGetRestrictionSession(result: result)
        default:
            result(FlutterMethodNotImplemented)
        }
    }

    private func handleConfigureShield(call: FlutterMethodCall, result: @escaping FlutterResult) {
        guard var configuration = call.arguments as? [String: Any] else {
            result(PluginErrors.invalidArguments(
                feature: Self.featureRestrictions,
                action: MethodNames.configureShield,
                message: PluginErrorMessage.missingShieldConfiguration
            ))
            return
        }

        let appGroupId = configuration["appGroupId"] as? String
        AppGroupStore.updateGroupIdentifier(appGroupId)
        configuration.removeValue(forKey: "appGroupId")

        if let typedData = configuration["iconBytes"] as? FlutterStandardTypedData {
            configuration["iconBytes"] = typedData.data
        } else if configuration["iconBytes"] is NSNull {
            configuration.removeValue(forKey: "iconBytes")
        }

        switch ShieldConfigurationStore.storeConfiguration(configuration, appGroupId: appGroupId) {
        case .success:
            result(nil)
        case .appGroupUnavailable(let resolvedGroupId):
            var diagnostic = "Unable to access App Group for shield configuration. resolvedAppGroupId=\(resolvedGroupId)"
            if let appGroupId {
                diagnostic += ", appGroupId=\(appGroupId)"
            }
            result(PluginErrors.internalFailure(
                feature: Self.featureRestrictions,
                action: MethodNames.configureShield,
                message: PluginErrorMessage.appGroupUnavailable,
                diagnostic: diagnostic
            ))
        }
    }

    private func handleSetRestrictedApps(call: FlutterMethodCall, result: @escaping FlutterResult) {
        guard #available(iOS 16.0, *) else {
            result(PluginErrors.unsupported(
                feature: Self.featureRestrictions,
                action: MethodNames.setRestrictedApps,
                message: PluginErrorMessage.restrictionsUnsupported
            ))
            return
        }
        guard let args = call.arguments as? [String: Any],
              let tokens = args["identifiers"] as? [String] else {
            result(PluginErrors.invalidArguments(
                feature: Self.featureRestrictions,
                action: MethodNames.setRestrictedApps,
                message: PluginErrorMessage.missingIdentifiers
            ))
            return
        }
        if !tokens.isEmpty, let preflightError = restrictionPreflightError(action: MethodNames.setRestrictedApps) {
            result(preflightError)
            return
        }
        let decodeResult = ShieldManager.shared.decodeTokens(base64Tokens: tokens)
        if !decodeResult.invalidTokens.isEmpty {
            result(PluginErrors.invalidArguments(
                feature: Self.featureRestrictions,
                action: MethodNames.setRestrictedApps,
                message: PluginErrorMessage.unableToDecodeTokens,
                diagnostic: "invalidTokens=\(decodeResult.invalidTokens)"
            ))
            return
        }

        switch RestrictionStateStore.storeDesiredRestrictedApps(decodeResult.appliedBase64Tokens) {
        case .success:
            break
        case .appGroupUnavailable(let resolvedGroupId):
            result(PluginErrors.internalFailure(
                feature: Self.featureRestrictions,
                action: MethodNames.setRestrictedApps,
                message: PluginErrorMessage.appGroupUnavailable,
                diagnostic: "resolvedAppGroupId=\(resolvedGroupId)"
            ))
            return
        }

        applyDesiredRestrictionsIfNeeded()
        result(decodeResult.appliedBase64Tokens)
    }

    private func handleAddRestrictedApp(call: FlutterMethodCall, result: @escaping FlutterResult) {
        guard #available(iOS 16.0, *) else {
            result(PluginErrors.unsupported(
                feature: Self.featureRestrictions,
                action: MethodNames.addRestrictedApp,
                message: PluginErrorMessage.restrictionsUnsupported
            ))
            return
        }
        guard let args = call.arguments as? [String: Any],
              let token = args["identifier"] as? String else {
            result(PluginErrors.invalidArguments(
                feature: Self.featureRestrictions,
                action: MethodNames.addRestrictedApp,
                message: PluginErrorMessage.missingIdentifier
            ))
            return
        }
        if let preflightError = restrictionPreflightError(action: MethodNames.addRestrictedApp) {
            result(preflightError)
            return
        }

        let decodeResult = ShieldManager.shared.decodeTokens(base64Tokens: [token])
        if !decodeResult.invalidTokens.isEmpty {
            result(PluginErrors.invalidArguments(
                feature: Self.featureRestrictions,
                action: MethodNames.addRestrictedApp,
                message: PluginErrorMessage.unableToDecodeToken,
                diagnostic: "invalidTokens=\(decodeResult.invalidTokens)"
            ))
            return
        }

        ensureDesiredRestrictionsInitializedFromManagedStore()
        var desired = RestrictionStateStore.loadDesiredRestrictedApps()
        if desired.contains(token) {
            result(false)
            return
        }
        desired.append(token)

        switch RestrictionStateStore.storeDesiredRestrictedApps(desired) {
        case .success:
            break
        case .appGroupUnavailable(let resolvedGroupId):
            result(PluginErrors.internalFailure(
                feature: Self.featureRestrictions,
                action: MethodNames.addRestrictedApp,
                message: PluginErrorMessage.appGroupUnavailable,
                diagnostic: "resolvedAppGroupId=\(resolvedGroupId)"
            ))
            return
        }

        applyDesiredRestrictionsIfNeeded()
        result(true)
    }

    private func handleRemoveRestriction(call: FlutterMethodCall, result: @escaping FlutterResult) {
        guard #available(iOS 16.0, *) else {
            result(PluginErrors.unsupported(
                feature: Self.featureRestrictions,
                action: MethodNames.removeRestriction,
                message: PluginErrorMessage.restrictionsUnsupported
            ))
            return
        }
        guard let args = call.arguments as? [String: Any],
              let token = args["identifier"] as? String else {
            result(PluginErrors.invalidArguments(
                feature: Self.featureRestrictions,
                action: MethodNames.removeRestriction,
                message: PluginErrorMessage.missingIdentifier
            ))
            return
        }

        let decodeResult = ShieldManager.shared.decodeTokens(base64Tokens: [token])
        if !decodeResult.invalidTokens.isEmpty {
            result(PluginErrors.invalidArguments(
                feature: Self.featureRestrictions,
                action: MethodNames.removeRestriction,
                message: PluginErrorMessage.unableToDecodeToken,
                diagnostic: "invalidTokens=\(decodeResult.invalidTokens)"
            ))
            return
        }

        ensureDesiredRestrictionsInitializedFromManagedStore()
        var desired = RestrictionStateStore.loadDesiredRestrictedApps()
        let previousCount = desired.count
        desired.removeAll { $0 == token }
        let changed = desired.count != previousCount

        switch RestrictionStateStore.storeDesiredRestrictedApps(desired) {
        case .success:
            break
        case .appGroupUnavailable(let resolvedGroupId):
            result(PluginErrors.internalFailure(
                feature: Self.featureRestrictions,
                action: MethodNames.removeRestriction,
                message: PluginErrorMessage.appGroupUnavailable,
                diagnostic: "resolvedAppGroupId=\(resolvedGroupId)"
            ))
            return
        }

        applyDesiredRestrictionsIfNeeded()
        result(changed)
    }

    private func handleIsRestricted(call: FlutterMethodCall, result: @escaping FlutterResult) {
        guard #available(iOS 16.0, *) else {
            result(PluginErrors.unsupported(
                feature: Self.featureRestrictions,
                action: MethodNames.isRestricted,
                message: PluginErrorMessage.restrictionsUnsupported
            ))
            return
        }
        guard let args = call.arguments as? [String: Any],
              let token = args["identifier"] as? String else {
            result(PluginErrors.invalidArguments(
                feature: Self.featureRestrictions,
                action: MethodNames.isRestricted,
                message: PluginErrorMessage.missingIdentifier
            ))
            return
        }

        let decodeResult = ShieldManager.shared.decodeTokens(base64Tokens: [token])
        if !decodeResult.invalidTokens.isEmpty {
            result(PluginErrors.invalidArguments(
                feature: Self.featureRestrictions,
                action: MethodNames.isRestricted,
                message: PluginErrorMessage.unableToDecodeToken,
                diagnostic: "invalidTokens=\(decodeResult.invalidTokens)"
            ))
            return
        }
        ensureDesiredRestrictionsInitializedFromManagedStore()
        let restricted = RestrictionStateStore.loadDesiredRestrictedApps().contains(token)
        result(restricted)
    }

    private func handleRemoveAllRestrictions(call: FlutterMethodCall, result: @escaping FlutterResult) {
        guard #available(iOS 16.0, *) else {
            result(PluginErrors.unsupported(
                feature: Self.featureRestrictions,
                action: MethodNames.removeAllRestrictions,
                message: PluginErrorMessage.restrictionsUnsupported
            ))
            return
        }

        switch RestrictionStateStore.storeDesiredRestrictedApps([]) {
        case .success:
            break
        case .appGroupUnavailable(let resolvedGroupId):
            result(PluginErrors.internalFailure(
                feature: Self.featureRestrictions,
                action: MethodNames.removeAllRestrictions,
                message: PluginErrorMessage.appGroupUnavailable,
                diagnostic: "resolvedAppGroupId=\(resolvedGroupId)"
            ))
            return
        }

        ShieldManager.shared.clearRestrictions()
        result(nil)
    }

    private func handleGetRestrictedApps(call: FlutterMethodCall, result: @escaping FlutterResult) {
        guard #available(iOS 16.0, *) else {
            result([])
            return
        }
        ensureDesiredRestrictionsInitializedFromManagedStore()
        let tokens = RestrictionStateStore.loadDesiredRestrictedApps()
        result(tokens)
    }

    private func handleIsRestrictionSessionActiveNow(result: @escaping FlutterResult) {
        guard #available(iOS 16.0, *) else {
            result(false)
            return
        }

        ensureDesiredRestrictionsInitializedFromManagedStore()
        applyDesiredRestrictionsIfNeeded()
        let restrictedApps = RestrictionStateStore.loadDesiredRestrictedApps()
        let isPausedNow = RestrictionStateStore.loadPausedUntilEpochMs() > 0
        let isPrerequisitesMet = restrictionMissingPrerequisites().isEmpty
        result(!restrictedApps.isEmpty && !isPausedNow && isPrerequisitesMet)
    }

    private func handleIsRestrictionSessionConfigured(result: @escaping FlutterResult) {
        guard #available(iOS 16.0, *) else {
            result(false)
            return
        }

        ensureDesiredRestrictionsInitializedFromManagedStore()
        let restrictedApps = RestrictionStateStore.loadDesiredRestrictedApps()
        result(!restrictedApps.isEmpty)
    }

    private func handlePauseEnforcement(call: FlutterMethodCall, result: @escaping FlutterResult) {
        guard #available(iOS 16.0, *) else {
            result(PluginErrors.unsupported(
                feature: Self.featureRestrictions,
                action: MethodNames.pauseEnforcement,
                message: PluginErrorMessage.restrictionsUnsupported
            ))
            return
        }

        guard let args = call.arguments as? [String: Any],
              let durationValue = args["durationMs"] as? NSNumber else {
            result(PluginErrors.invalidArguments(
                feature: Self.featureRestrictions,
                action: MethodNames.pauseEnforcement,
                message: "Missing or invalid 'durationMs' argument"
            ))
            return
        }
        let durationMs = durationValue.int64Value
        if durationMs <= 0 {
            result(PluginErrors.invalidArguments(
                feature: Self.featureRestrictions,
                action: MethodNames.pauseEnforcement,
                message: "Missing or invalid 'durationMs' argument"
            ))
            return
        }

        if RestrictionStateStore.loadPausedUntilEpochMs() > 0 {
            result(PluginErrors.invalidArguments(
                feature: Self.featureRestrictions,
                action: MethodNames.pauseEnforcement,
                message: "Restriction enforcement is already paused"
            ))
            return
        }

        let pausedUntilEpochMs = RestrictionStateStore.currentEpochMs() + durationMs
        switch RestrictionStateStore.storePausedUntilEpochMs(pausedUntilEpochMs) {
        case .success:
            break
        case .appGroupUnavailable(let resolvedGroupId):
            result(PluginErrors.internalFailure(
                feature: Self.featureRestrictions,
                action: MethodNames.pauseEnforcement,
                message: PluginErrorMessage.appGroupUnavailable,
                diagnostic: "resolvedAppGroupId=\(resolvedGroupId)"
            ))
            return
        }

        ShieldManager.shared.clearRestrictions()
        result(nil)
    }

    private func handleResumeEnforcement(result: @escaping FlutterResult) {
        guard #available(iOS 16.0, *) else {
            result(PluginErrors.unsupported(
                feature: Self.featureRestrictions,
                action: MethodNames.resumeEnforcement,
                message: PluginErrorMessage.restrictionsUnsupported
            ))
            return
        }

        switch RestrictionStateStore.storePausedUntilEpochMs(0) {
        case .success:
            break
        case .appGroupUnavailable(let resolvedGroupId):
            result(PluginErrors.internalFailure(
                feature: Self.featureRestrictions,
                action: MethodNames.resumeEnforcement,
                message: PluginErrorMessage.appGroupUnavailable,
                diagnostic: "resolvedAppGroupId=\(resolvedGroupId)"
            ))
            return
        }

        applyDesiredRestrictionsIfNeeded()
        result(nil)
    }

    private func handleGetRestrictionSession(result: @escaping FlutterResult) {
        guard #available(iOS 16.0, *) else {
            result([
                "isActiveNow": false,
                "isPausedNow": false,
                "pausedUntilEpochMs": NSNull(),
                "restrictedApps": [String]()
            ])
            return
        }

        ensureDesiredRestrictionsInitializedFromManagedStore()
        applyDesiredRestrictionsIfNeeded()
        let restrictedApps = RestrictionStateStore.loadDesiredRestrictedApps()
        let pausedUntilEpochMs = RestrictionStateStore.loadPausedUntilEpochMs()
        let isPausedNow = pausedUntilEpochMs > 0
        let isPrerequisitesMet = restrictionMissingPrerequisites().isEmpty
        result([
            "isActiveNow": !restrictedApps.isEmpty && !isPausedNow && isPrerequisitesMet,
            "isPausedNow": isPausedNow,
            "pausedUntilEpochMs": isPausedNow ? pausedUntilEpochMs : NSNull(),
            "restrictedApps": restrictedApps
        ])
    }

    @available(iOS 16.0, *)
    private func applyDesiredRestrictionsIfNeeded() {
        ensureDesiredRestrictionsInitializedFromManagedStore()
        guard restrictionMissingPrerequisites().isEmpty else {
            ShieldManager.shared.clearRestrictions()
            return
        }

        let desiredRestrictedApps = RestrictionStateStore.loadDesiredRestrictedApps()
        if desiredRestrictedApps.isEmpty {
            ShieldManager.shared.clearRestrictions()
            return
        }

        let isPausedNow = RestrictionStateStore.loadPausedUntilEpochMs() > 0
        if isPausedNow {
            ShieldManager.shared.clearRestrictions()
            return
        }

        let decodeResult = ShieldManager.shared.decodeTokens(base64Tokens: desiredRestrictedApps)
        if !decodeResult.invalidTokens.isEmpty {
            ShieldManager.shared.clearRestrictions()
            return
        }
        ShieldManager.shared.setRestrictedApps(decodeResult.tokens)
    }

    @available(iOS 16.0, *)
    private func ensureDesiredRestrictionsInitializedFromManagedStore() {
        let desiredRestrictedApps = RestrictionStateStore.loadDesiredRestrictedApps()
        if !desiredRestrictedApps.isEmpty {
            return
        }

        let currentlyApplied = ShieldManager.shared.getRestrictedApps()
        if currentlyApplied.isEmpty {
            return
        }

        _ = RestrictionStateStore.storeDesiredRestrictedApps(currentlyApplied)
    }

    @available(iOS 16.0, *)
    private func restrictionMissingPrerequisites() -> [String] {
        let isAuthorized = AuthorizationCenter.shared.authorizationStatus == .approved
        return isAuthorized ? [] : [Self.iosFamilyControlsKey]
    }

    @available(iOS 16.0, *)
    private func restrictionPreflightError(action: String) -> FlutterError? {
        let authorizationStatus = AuthorizationCenter.shared.authorizationStatus
        if authorizationStatus == .approved {
            return nil
        }

        let details: [String: Any] = [
            "feature": Self.featureRestrictions,
            "action": action,
            "platform": Self.platformIOS,
            "missing": [Self.iosFamilyControlsKey],
            "status": [
                "iosAuthorizationStatus": iosAuthorizationStatusKey(authorizationStatus)
            ],
        ]

        switch authorizationStatus {
        case .notDetermined:
            return PluginErrors.missingPermission(
                feature: Self.featureRestrictions,
                action: action,
                message: "Screen Time authorization is required for restrictions",
                missing: details["missing"] as? [String],
                status: details["status"] as? [String: Any]
            )
        case .denied:
            return PluginErrors.permissionDenied(
                feature: Self.featureRestrictions,
                action: action,
                message: "Screen Time authorization was denied",
                missing: details["missing"] as? [String],
                status: details["status"] as? [String: Any]
            )
        @unknown default:
            return PluginErrors.systemRestricted(
                feature: Self.featureRestrictions,
                action: action,
                message: "Screen Time authorization is unavailable",
                missing: details["missing"] as? [String],
                status: details["status"] as? [String: Any]
            )
        }
    }

    @available(iOS 16.0, *)
    private func iosAuthorizationStatusKey(_ status: AuthorizationStatus) -> String {
        switch status {
        case .approved:
            return "approved"
        case .denied:
            return "denied"
        case .notDetermined:
            return "notDetermined"
        @unknown default:
            return "unknown"
        }
    }
}
